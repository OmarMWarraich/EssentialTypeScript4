// When the app is executed using Node.js in the folder, any import statements can be 
// resolved using the JS generated by the TS compiler or by the packages installed in 
// the node_modules folder.
// The JS runtime starts with the application entry point-the index.js file that is 
// compiled from the index.ts file-and processes the import statement it contains. For
// each import statement, the runtime resolves the dependency and loads the required module
// which will be another JS file. Any import statements declared in the new JS file are
// processed in the same way, allowing all the dependencies in the app to be resolved so
// the code can be executed.
// The JS runtime doesnt know in advance what import statements each code file may contain
// and it doesnt know what JS files are required. But it doesnt matter because looking for
// files to resolve dependencies is a relatively quick operation since all the local files
// are easily accessible.
// This approach doesnt work as well for web applications, which dont have direct access
// to the file system. Instead, files have to be requested over HTTP, which can be a slow
// and expensive operations and which doesnt lend itself to easily checking multiple
// locations to resolvedependencies on files. Instead, a bundler is used, which resolves
// the dependencies during compilation and packages all the files that the application 
// uses into a single file. One HTTP request delivers all the JS required to run the
// application, and other content types, such as CSS, can be included in the file
// produced by the bundler, which is known as a bundle. 
// During the bundling process, the code and content can be minified and compressed,
// reducing the amount of bandwidth required to deliver the application to the client.
// Large applications can be split into multiple bundles so that optional code or content
// can be loaded separately and only when it is required.
// The most widely ised bundler is webpack, and it forms a key part of the toolchains, 
// used by React, angular and Vue.js, although you dont usuallu need to work with it
// directly. Webpack can be complex to work with, but it is supported by a variety of add-on
// packages that allow development toochains to be created for just about any type of project.
// Adding packages to the Project
// npm install --save-dev webpack@5.17.0
// npm install --save-dev webpack-cli@4.5.0
// npm install --save-dev ts-loader@8.0.14
// The webpack package contains the main bundler features, and the webpack-cli package
// adds command-line support. Webpack uses packages known as loaders to deal with different
// content types, and the ts-loader package adds support for compiling TypeScript files
// and feeding the compiled code into the bundle created by webpack. To configure webpack,
// add a file named webpack.config.js to the webapp folder with following contents.

module.exports = {
    mode: "development",
    devtool: "inline-source-map",
    entry: "./src/index.ts",
    output: { filename: "bundle.js" },
    resolve: { extensions: [".ts", ".js"] },
    module: {
        rules: [
            { test: /\.ts/, use: "ts-loader", exclude: /node_modules/  }
        ]
    }
}

// The entry and output settings tell webpack to start with the src/index.ts file when 
// resolving the application's dependencies and to give the bundle file the name bundle.js.
// The other settings configure webpack to use the ts-loader package to process files
// with the ts file extension.

// npx webpack

// node dist/bundle.js     
//> Web App
